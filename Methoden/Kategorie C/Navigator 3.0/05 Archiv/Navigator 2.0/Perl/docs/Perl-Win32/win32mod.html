<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>win32mod1</TITLE>
<META NAME="Template" CONTENT="C:\Program Files\Microsoft Office\Office\html.dot">
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" VLINK="#000080">

<H1 ALIGN="CENTER">Perl for Win32</H1>
<H2 ALIGN="CENTER">System Module Extensions</H2>
<P><HR></P>
<P><A HREF="win32ext.html">Win32 Extensions</A>
<p><A HREF="#contents">Table of Contents</A>
<p><A HREF="http://www.ActiveWare.com">ActiveWare</A></P>
<P><HR></P>
<H3>Conventions</H3>
<P>The following conventions are used throughout this document.</P>

<UL>
<LI>arguments:</LI></UL>

<I><P>argname</I><B> </B>a required argument. </P>
<I><P>[argname]</I><B> </B>an optional argument.</P>
<I><P>(out)</I> <I>argname</I> an output argument, typically requires a reference for this argument.</P>

<UL>
<LI>Return values</LI></UL>

<P>All methods and functions return TRUE on success. FALSE on failure or unless otherwise noted. If an error occurs the Perl built in variable, '$!' is set. A reference to '$!' as a string will return a string explaining the error.</P>

<UL>
<LI>All classes contain a destructor DESTROY, that can be called to destroy objects. The destructor is called automaticly when the object goes out of scope. The destructor frees any System Objects associated with the Perl Object. </LI></UL>

<P><A NAME="contents"></A></P>
<H3>Table of Contents</H3>
<P><A NAME="process_top"></A><A HREF="#Process">Win32::Process</A> </P>
<P><A NAME="semaphore_top"></A><A HREF="#Semaphore">Win32::Semaphore</A> </P>
<P><A NAME="ipc_top"></A><A HREF="#IPC">Win32::IPC</A> </P>
<P><A NAME="mutex_top"></A><A HREF="#Mutex">Win32::Mutex</A> </P>
<P><A NAME="changenotify_top"></A><A HREF="#ChangeNotify">Win32::ChangeNotify</A> </P>
<P><A NAME="eventlog_top"><A HREF="#Eventlog">Win32::Eventlog</A> </P>
<P><A NAME="registry_top"></A><A HREF="#Registry">Win32::Registry</A> </P>
<P><A NAME="netadmin_top"></A><A HREF="#NetAdmin">Win32::NetAdmin</A> </P>
<P><A NAME="file_top"></A><A HREF="#File">Win32::File</A> </P>
<P><A NAME="service_top"></A><A HREF="#Service">Win32::Service</A> </P>
<P><A NAME="netresource_top"></A><A HREF="#NetResource">Win32::NetResource</A> </P>
<P><HR></P>
<H3><A NAME="Process"></A><A HREF="#contents"></A>Win32::Process</H3>

<UL>
<LI><A HREF="#process_functions">Functions</A> </LI>
<LI><A HREF="#process_methods">Methods</A> </LI>
<LI><A HREF="#process_examples">Examples</A></LI></UL>

<P><A NAME="process_functions"></A><A HREF="#Process"></A><B>Functions</P>
Create(</B>(out)<I>$ProcessObj,$ApplicationName,$CommandLine,$InheritHandles,$CreateOptions,$CurrentDir</I><B>)</B>
<DL>
<DT>(out)$ProcessObj </DT>
<DD>Reference to a Process Object.</DD>
<DT>$ApplicationName</DT>
<DD>Full path of executable module.</DD>
<DT>$CommandLine</DT>
<DD>Command Line as seen by executable</DD>
<DT>$InheritHandles</DT>
<DD>Flag for handle inheritance. 1=true, 0=false.</DD>
<DT>$CreateOptions </DT>
<DD>Process creation flags. (see description below)</DD>
<DT>$CurrentDir</DT>
<DD>Location of working directory for executable</DD>
</DL>
<P>The Create function acts as a constructor for the Process class. The executable module (<I>$ApplicationName</I>) is executed and passed <I>$CommandLine</I>. <I>$CommandLine</I> is the full command line for the new process. <BR>
To execute a perl script: <BR>
<CODE>$CommandLine = 'perl myscript.pl';</CODE> <BR>
The options for CreateOptions are: </P>
<B><PRE>Option Name</B>                <B>Description</B>              
CREATE_DEFAULT_ERROR_MODE  Give the new process     
                           the default error mode.  

CREATE_NEW_CONSOLE         The new process has a    
                           new console. This can't  
                           be used with             
                           DETACHED_PROCESS.        

CREATE_NEW_PROCESS_GROUP   The new process is the   
                           root of a new process    
                           group.                   

CREATE_SEPARATE_WOW_VDM    The new process is run   
                           in it's own Virtual Dos  
                           Machine (VDM). Only      
                           applicable to 16-bit     
                           apps.                    

CREATE_SUSPENDED           The primary thread of    
                           the process is created   
                           in a suspended state.    
                           The process can be       
                           started with the Resume  
                           method below.            

CREATE_UNICODE_ENVIRONMENT The environment block    
                           of the new process uses  
                           UNICODE characters.      

DEBUG_PROCESS              The calling process is   
                           treated as a debugger,   
                           and the new process is   
                           being debugged.          

DEBUG_ONLY_THIS_PROCESS    If the calling process   
                           is being debugged, then  
                           the new process will     
                           not be debugged.         

DETACHED_PROCESS           The new process does     
                           not have access to the   
                           console of the calling   
                           process.                 </PRE>
<P><A NAME="process_methods"></A><A HREF="#Process"></A><B>Methods</P>
Kill(</B><I>$ExitCode</I><B>)</B><DL>
<DT>$ExitCode </DT>
<I><DD>The Exit code that the process should return.</DD>
</DL>
</I><P>Kills the process. </P>
<B><P>Suspend()</P>
</B><P>Suspend the process.</P>
<B><P>Resume()</P>
</B><P>Resume a suspended process. This call can be used to resume a process that was created with the CREATE_SUSPENDED flag.</P>
<B>GetPriorityClass((out)</B>$Priority<B>)
<I><DL>
<DT>(out)</B></I>$Priority</DT>
<DD>The priority class of the process. </DD>
</DL>
<B>SetPriorityClass(</B>$Priority<B>)
</B><I><DL>
<DT>$</I>Priority</DT>
<DD>The Priority to set the Process to.</DD>
</DL>
<P>The <B>GetPriorityClass</B> and <B>SetPriorityClass</B> methods allow control over the priority of the process. The $Priority can be one of </P>
<PRE>
<B>PriorityClass</B>        <B>Description</B>                  
IDLE_PRIORITY_CLASS  Indicates a process whose
                     threads run only when the
                     system is idle. (ex: screensaver)

NORMAL_PRIORITY_CLASS  Normal process scheduling.
HIGH_PRIORITY_CLASS  Indicates a process that     
                     performs time-critical
                     tasks that must be executed
                     immediately. 

REALTIME_PRIORITY_CLASS The highest process
                     priority, even pre-empts OS threads.                     </PRE>
<B>GetExitCode((out)</B><I>$ExitCode</I><B>)
<I><DL>
<DT>(out)</B>$ExitCode </DT>
</I><DD>The exit code.</DD>
</DL>
<P>GetExitCode can be used to find out how or if a process has exited.</P>
<B>Wait(</B><I>$Timeout</I><B>)</B>
<I><DL>
<DT>$Timeout </DT>
</I><DD>The number of milliseconds to wait for process to end, for no timeout value, use INFINITE. </DD>
</DL>
<P>Wait for the process to exit. Wait returns FALSE if it times out. $! Is set to WAIT_FAILED in this case.</P>
<P><A NAME="process_examples"></A><A HREF="#Process"></A><B>Example</P>
</B><PRE>
        #'use' the process module.
        use Win32::Process;
        #theWin32:: module. Includes the Win32 error checking etc.
        # see Win32:: section for included functions.
        use Win32;
     
        sub Error
        { 
           print Win32::FormatMessage(Win32::GetLastError());
        }

        #Create the process object.
        Win32::Process::Create($ProcessObj,  #object to hold process.
                             "C:/winnt35/system32/Notepad.exe" #executable
                             "Notepad temp.txt" #command line
                             0,   #no inheritance.
                             DETACHED_PROCESS, #separate process
                             ".") || die &amp;Error; #current dir.

        #Set the process priority
        $ProcessObj-&gt;SetPriorityClass(NORMAL_PRIORITY_CLASS) || die &amp;Error;

        #Wait for the process to end. NO timeout 
        $ProcessObj-&gt;Wait(INFINITE) || die &amp;Error;

        $ProcessObj-&gt;GetExitCode($ExitCode) || die &amp;Error;
        print" Notepad exited with $ExitCode\n";</PRE>
<P><HR></P>
<H3><A NAME="Semaphore"></A><A HREF="#contents"></A>Win32::Semaphore</H3>

<UL>
<LI><A HREF="#semaphore_functions">Functions</A> </LI>
<LI><A HREF="#semaphore_methods">Methods</A> </LI>
<LI><A HREF="#semaphore_examples">Examples</A> </LI></UL>

<P><A NAME="semaphore_functions"></A><A HREF="#Semaphore"></A><B>Functions</P>
Create(</B>(out)$SemaphoreObj,$InitialCount,$MaxCount,$Name<B>)</B><DL>
<DT>$SemaphoreObj </DT>
<DD>Reference to a Semaphore Object.</DD>
<DT>$InitialCount </DT>
<DD>The initial count of the semaphore object.</DD>
<DT>$MaxCount </DT>
<DD>The maximum count of the semaphore.</DD>
<DT>$Name </DT>
<DD>A string containing a name for the semaphore. </DD>
</DL>
<P>The Create Function creates a semaphore object and returns the reference in the $SemaphoreObj scalar. The semaphore is created with an initial value of $InitialCount. The maximum number of accesses allowed is set to $MaxCount.</P>
<B>Destroy(</B>$SemaphoreObj<B>)</B>
<DL>
<DT>$SemaphoreObj</DT>
<DD>Reference to a Semaphore Object. </DD>
</DL>
<P>The DESTROY Function destroys the Semaphore object. This method is automatically called by Perl when the $SemaphoreObject scalar goes out of scope. <A NAME="semaphore_methods"></A><A HREF="#Semaphore"></A></P>
<B><P>Methods</P>
Wait(</B><I>$TimeOut </I><B>)</B>
<DL>
<DT>$TimeOut </DT>
<DD>Time to wait (in Milliseconds) </DD>
</DL>
<P>The Wait method causes the calling process to wait on the Semaphore. If the Semaphore is not released in <I>$TimeOut </I>milliseconds, the call returns, and the return value should be checked. For no timeout value, use the predefined constant INFINITE. </P>
<B>Release(</B><I>$ReleaseCount, <B>(out)</B>$lastCount</I><B>)</B>
<DL>
<DT>$ReleaseCount</DT>
<DD>Amount to increase Semaphore count</DD>
<DT>$LastCount</DT>
<DD>Previous value of the Semaphore.</DD>
</DL>
<P>The Release Method releases a semaphore and increments the count by $ReleaseCount. The value of the Semaphore before the change is recorded in the $LastCount var. </P>
<P><A NAME="semaphore_examples"></A><A HREF="#Semaphore"></A><B>Example</P>
</B><PRE>
        use Win32::Semaphore;
        use Win32;

        Win32::Semaphore::Create($Sem,1,1,"Sem")||die &amp;Error;
        #wait for access to the shared resource.

        if($Sem-&gt;Wait(INFINITE))
        {
                #Access the shared resource here. 
                &amp;Access($Shared_Resource);
                $Sem-&gt;Release(1,$last);
        }
        else
        {
                print"Could not get access to shared resource\n";
        }</PRE>
<P><HR></P>
<H3><A NAME="IPC"></A><A HREF="#contents"></A>Win32::IPC</H3>

<UL>
<LI><A HREF="#ipc_functions">Functions</A> </LI>
<LI><A HREF="#ipc_examples">Examples</A></LI></UL>

<P><A NAME="ipc_functions"></A><A HREF="#IPC"></A><B>Functions</P>
WaitForMultipleObjects(</B>@objects , $WaitAll ,$TimeOut<B>)</B>
<DL>
<DT>@objects </DT>
<DD>#a list of object references. </DD>
<DT>$WaitAll </DT>
<DD>#TRUE: wait for all objects. FALSE wait for first object to return. </DD>
<DT>$TimeOut;</DT>
<DD>#timeout value in milliseconds.</DD>
</DL>
<P>The WaitForMultipleObjects is used to coordinate multiple events. The @objects array can hold objects of type: Semaphore, Mutex, Process, or ChangeNotify. If the $WaitAll var contains a true value (non zero) then the call waits for all of the objects, otherwise, it will return when the first object returns.</P>
<P><A NAME="ipc_examples"></A><A HREF="#IPC"></A><B>Example</P>
</B><PRE>
        Win32::Semaphore::Create($Sem, 1,1,"Sem") || die $!;
        Win32::Mutex::Create($mut,0,"Mut") || die $!;
        #note: the WaitForMultipleObjects call is inherited, and
        # not referenced directly.
        Win32::Semaphore::WaitForMultipleObjects(($Sem,$mut),1, 10000) || die $!;</PRE>
<H4>Implementation note</H4>
<P>The IPC package is inherited by Win32::Process, Win32::Semaphore, Win32::ChangeNotify, and Win32::Mutex, it does not need to be implicitly 'use'd. </P>
<P><HR></P>
<H3><A NAME="Mutex"></A><A HREF="#contents"></A>Win32::Mutex</H3>

<UL>
<LI><A HREF="#mutex_functions">Functions</A> </LI>
<LI><A HREF="#mutex_examples">Examples</A></LI></UL>

<P><A NAME="mutex_functions"></A><A HREF="#Mutex"></A><B>Functions</P>
Create(</B>(out) $MutexObj, $InitialOwner,$Name<B>)</B>
<DL>
<DT>$MutexObj</DT>
<DD>Reference to a mutex object. </DD>
<DT>$InitialOwner</DT>
<DD>Flag to indicate initial ownership. </DD>
<DT>$Name</DT>
<DD>Name of mutex </DD>
</DL>
<P>Create creates a mutex object and returns the reference in $MutexObj. If the $InitialOwner flag is set (nonzero) then the process calling the Create function has immediate ownership of the mutex. Otherwise, the mutex is available. $Name can be used by other processes in the Win32::Mutex::Open call to create an object to reference an already created mutex. </P>
<B>Open(</B>$MutexObj, $Name<B>)</B>
<DL>
<DT>(out)$MutexObj </DT>
<DD>Reference to a mutex object. </DD>
<DT>$Name</DT>
<DD>A string naming an already created mutex.</DD>
</DL>
<P>Open creates a mutex object to access an already Created mutex. The $Name must point to an already created object or this call will fail. Methods Release() Release relinquishes ownership of the mutex, allowing anyone Waiting on the mutex to take ownership. </P>
<B>Wait(</B>$TimeOut<B>)</B><DL>
<DT>$TimeOut </DT>
<DD>Time out for wait (in milliseconds).</DD>
</DL>
<P>Wait causes the calling process to wait for $TimeOut milliseconds for the ownership of the mutex. If the mutex doesn't come available before the timeout, the call returns false. To specifiy and infinite timeout, set $TimeOut to INFINITE.</P>
<P><A NAME="mutex_examples"></A><A HREF="#Mutex"></A><B>Example</P>
</B><PRE>
       #Create a mutex object
       Win32::Mutex::Create($Mut,0, "MyMutex")|| die $!;
       #Use it
       sub EnterArea
       { 
               local($mut) = @_;
               $mut-&gt;wait(5000)||die $!;
               #access away!!! 
               $mut-&gt;Release();
       }</PRE>
<P><HR></P>
<H3><A NAME="ChangeNotify"></A><A HREF="#contents"></A>Win32::ChangeNotify </H3>
<P></A></P>

<UL>
<LI><A HREF="#con_functions">Functions</A> </LI>
<LI><A HREF="#con_methods">Methods</A> </LI>
<LI><A HREF="#con_examples">Examples</A> </LI></UL>

<P><A NAME="con_functions"></A><A HREF="#ChangeNotify"></A><B>Functions</P>
FindFirst((out)</B>$Object,$PathName,$WatchSubtree,$Filter<B>)</B><DL>
<DT>(out)$Object </DT>
<DD>ChangeNotify Object. </DD>
<DT>$PathName</DT>
<DD>Path to directory to monitor </DD>
<DT>$WatchSubTree</DT>
<DD>TRUE: notify for changes to subtree. FALSE-don't monitor subtree. </DD>
<DT>$Filter</DT>
<DD>Specifies the filter conditions that satisfy a change notification wait. The FindFirst function creates a notification object, and returns the reference in $Object. $Filter can be one or more of the following:</DD>
</DL>
<PRE>
Filter Option                Description                
FILE_NOTIFY_CHANGE_FILE_NAME Any naming changes in the  
                             watched directory satisfy  
                             a change notification      
                             wait.  Changes include     
                             renames, deletions, and    
                             creations.                 

FILE_NOTIFY_CHANGE_DIR_NAME  Any directory name         
                             changes.                   

FILE_NOTIFY_CHANGE_ATTRIBUTES Any attribute changes     
                                                       
FILE_NOTIFY_CHANGE_SIZE      Any file-size change.      
                             The notification only      
                             occurs when the change is  
                             written to disk. If disk   
                             IO is cached, the change   
                             occurs when the cache is   
                             flushed.                   

FILE_NOTIFY_CHANGE_LAST_WRITE Any change to the last     
                             write time for a file.     
                             See above for notes on     
                             caching.                   

FILE_NOTIFY_CHANGE_SECURITY  Any security descriptor    
                             changes in the directory.  </PRE>
<P><A NAME="con_methods"></A><A HREF="#ChangeNotify"></A><B>Methods</P>
<DL>FindNext()</B>
<DD>The FindNext method requests that the operating system signal the change notification object the next time it detects an appropriate change.</DD></DL>
<DL><B>Close()</B><DD>Stops the notification object monitoring.</DD></DL>
<B><DL>Wait(</B>$TimeOut<B>)</B><DD>$TimeOut #time out in milliseconds. The Wait method causes the calling process to block until notification of the change.</DD></DL>
<B><DL>DESTROY()</B><DD>The DESTROY method is called when the ChangeNotify object goes out of scope. This will close the notification.</DD></DL>
<P><A NAME="con_examples"></A><A HREF="#ChangeNotify"></A><B>Example</P>
</B><PRE>
       Win32::ChangeNotify::FindFirst($cnobj,
                             "d:/mydir/",1,"
                             FILE_NOTIFY_CHANGE_FILE_NAME") || die $!; 

       #Wait for the change. 
       $cnobj-&gt;FindNext();
       $cnobj-&gt;Wait(INFINITE); 

       #do something about the change. 
       &amp;Notify($Someone);
       $cnobj-&gt;Close;</PRE>
<P><HR></P>
<H3><A NAME="Eventlog"></A><A HREF="#contents"></A>Win32::Eventlog </H3>

<UL>
<LI><A HREF="#eventlog_functions">Functions</A> </LI>
<LI><A HREF="#eventlog_methods">Methods</A> </LI>
<LI><A HREF="#eventlog_examples">Examples</A></LI></UL>

<P><A NAME="eventlog_functions"></A><A HREF="#Eventlog"></A><B>Functions</P>
<DL>Open((out)</B>$EventObj, $SourceName, [$ServerName]<B>)</B>
<DT>(out) $EventObj;</DT>
<DD>Reference to an EventLog Object.</DD>
<DT>$SourceName;</DT>
<DD>Name of the source of the event.</DD>
<DT>$ServerName;</DT>
<DD>Optional: name of machine. If none, assumes local.</DD>
</DL>
<P>Open the eventlog on the specified machine, if no server is specified, the local machine is used. An Eventlog object is returned in $EventObj. </P>
<B><P>&nbsp;</P>
<DL>OpenBackup(</B>(out)$EventObj, $FileName, [$ServerName]<B>)</B>
<DT>(out)$EventObj </DT>
<DD>Reference to an Eventlog Object.</DD>
<DT>$FileName </DT>
<DD>name of the file containing the backup eventlog.</DD>
<DT>$ServerName </DT>
<DD>Optional: UNC name of the server containing the backup log.</DD>
</DL>
<P>Open a backup eventlog and return an object to control it. If $ServerName is not given the local machine is used.</P>
<B><P><A NAME="eventlog_methods"></A></P>
<P>&nbsp;</P>
<P>Methods</P>
<DL>
<DT>Backup(</B>$filename<B>)</B> </DT>
<DD>$filename</DD>
<DT>file to write the eventlog to. </DT>
<DT>Save the current open event log to a file </DT>
<B><DT>&nbsp;</DT>
<DT>Read(</B>$ReadFlags,$RecordOffset,(out)%EventInfo<B>)</B> </DT>
<DT>(out) $ReadFlags </DT>
<DD>Specifies how to read log</DD>
<DT>$RecordOffset</DT>
<DD>Number of first record </DD>
<DT>(out)%EventInfo </DT>
<DD>Event information </DD>
<DT>The Read method reads an entry from the eventlog. $ReadFlags can be any combination of: </DT>
</DL>
<PRE>
ReadFlag option              Description                
EVENTLOG_FORWARDS_READ       Eventlog is read in        
                             forward chronological      
                             order.                     

EVENTLOG_BACKWARDS_READ      Eventlog is read in        
                             reverse chronological      
                             order.                     

EVENTLOG_SEEK_READ           The read begins at the     
                             record specified by the    
                             $RecordOffset parameter.   
                             Must also specify          

EVENT_LOG_FORWARD_READ or  
EVENTLOG_BACKWARDS_READ.   

EVENTLOG_SEQUENTIAL_READ     The read continues         
                             sequentially from the      
                             last read call.            </PRE>
<DL>
<DT>See the Report method for information on the %EventInfo hash. </DT>
<B><DT>&nbsp;</DT>
<DT>Report(</B>$EventInfo<B>)</B> </DT>
<DT>$EventInfo </DT>
<DD>A hash containing the event info.</DD>
</DL>
<P>Reports an event. Implicitly calls RegisterEventSource. </P>
<P>The options for $Event are:</P>
<PRE>
$Event Options                Description               
EVENTLOG_ERROR_TYPE           Error event               
EVENTLOG_WARNING_TYPE         Warning event             
EVENTLOG_INFORMATION_TYPE     Information event         
EVENTLOG_AUDIT_SUCCESS_TYPE   Success Audit event       
EVENTLOG_AUDIT_FAILURE_TYPE   Failure Audit event.      


$EventInfo contains the following:
Key&#9;&#9;Value                                    
Category&#9;integer value for the category of the event (app defined)                     
EventID&#9;&#9;ID value of the Event. Source specific, any value.                               
Data&#9;&#9;The Raw binary data                      
Strings&#9;&#9;Any text strings to merge                </PRE>
<P></P>
<DL><B>GetOldest</B>(<B>(out)</B>$oldest<B>)</B><DD>Returns the Absolute record number of the oldest record in the event log. </DL>
<P></P>
<DL><B>GetNumber((out)</B>$NumberOfEvents<B>)</B><DD>Returns the number of events.</DL>
<P></P>
<DL><B>Clear(</B>[ $filename ]<B>)</B><DD>If the $filename option is given, then the current eventlog is written to the file Clears the event log.</DL>
<B><P><A NAME="eventlog_examples"></A></P>
<P>Example 1</P>
</B><PRE>
&#9;use Win32::Eventlog;
&#9;sub TEST1
&#9;{ 
&#9;&#9;my $number, $EventLog;
&#9;&#9;Win32::EventLog::Open($EventLog , "System", '') || die $!;
&#9;&#9;$EventLog-&gt;GetNumber($number) || die $!;
&#9;&#9;print "There are $number records in the System Event Log\n";
&#9;}

&#9;TEST1</PRE>
<B><P>Example 2</P>
</B><PRE>
&#9;use Win32::Eventlog;
&#9;sub TEST2
&#9;{
        &#9;my $number, $EventLog;
&#9;        # open the event log.
        &#9;Win32::EventLog::Open($EventLog , "PerlApp", '') || die $!;
&#9;        # define the event to log.
        &#9;$Event =
&#9;        {
        &#9;        'EventType' =&gt; EVENTLOG_INFORMATION_TYPE,
                &#9;'Category' =&gt; 0,
&#9;                'EventID' =&gt; 0x1003,
        &#9;        'Data' =&gt; '',
                &#9;'Strings' =&gt; "Test report",
&#9;        };
        &#9;# report the event and check the error
&#9;        $EventLog-&gt;Report($Event) || die $!;
&#9;}
&#9;TEST2</PRE>
<P><HR></P>
<H3><A NAME="Registry"></A><A HREF="#contents"></A>Win32::Registry</H3>

<UL>
<LI><A HREF="#registry_methods">Methods</A> </LI>
<LI><A HREF="#registry_examples">Examples</A> </LI></UL>

<P><A NAME="registry_methods"></A><A HREF="#Registry"></A><B>Methods</P>
<DL>Open(</B>$key, <B>(out)</B>RegistryObj<B>)</B>
<DT>(out)RegistryObj</DT>
<DD>Reference to a reference object </DD>
<DT>$key </DT>
<DD>Pre-defined key.</DD></DL>
<DL>Open the specified registry key and create an object to access the key. If the specified key does not exist, it is not created.$Key can hold any already opened key. When the Registry module is loaded, four Registry objects are created in the main:: namespace. These predefined registry objects are:</DL>
<UL>
<LI>$HKEY_CLASSES_ROOT</LI>
<LI>$HKEY_CURRENT_USER</LI>
<LI>$HKEY_LOCAL_MACHINE</LI>
<LI>$HKEY_USERS</LI>
<LI>$HKEY_PERFORMANCE_DATA</LI>
<LI>$HKEY_CURRENT_CONFIG</LI>
<LI>$HKEY_DYN_DATA</LI>
</UL>

<P></P>
<B><DL>Create((out)</B>$RegistryObj, $key<B>)</B>
<DT>$RegistryObj </DT>
<DD>Reference to a registy object.</DD>
<DT>$key </DT>
<DD>Name of a key. </DD>
</DL>
<P>If the key exists, then open it, otherwise create it. The User must have the security to create a key. </P>
<P></P>
<B><DL>SetValue(</B>$subkey,$type,$value<B>)</B>
<DT>$subkey</DT>
<DD>Name of subkey</DD>
<DT>$type</DT>
<DD>Type of value </DD>
<DT>$value</DT>
<DD>Value</DD>
</DL>
<P>Set the value of the subkey of the current key to be $value.</P>
<B><DL>QueryValue(</B>$name, <B>(out)</B>$value<B>)</B>
<B><DT>(out)</B>$value</DT>
<DD>Value of var $name</DD>
<DT>$name </DT>
<DD>Name of value to query.</DD>
</DL>
<P>Sets $value for the specific name value in the current key. </P>
<P></P>
<B><DL>QueryKey((out)</B>$class,<B>(out)</B>$NumberOfSubkeys,<B>(out)</B> NumberOfValues<B>)
<DT>(out)</B>$class </DT>
<DD>Class of the key.</DD>
<B><DT>(out)</B>$NumberOfSubkeys </DT>
<DD>Number of subkeys of the current key.</DD>
<B><DT>(out)</B>NumberOfValues </DT>
<DD>Number of values in the current key.</DD>
</DL>
<P>Get the information from the current key.</P>
<P></P>
<B><DL>GetKeys((out)</B>\@Subkeys<B>)</B>
<DT>\@SubKeys</DT>
<DD>A reference to a list to hold the subkeys.</DD>
</DL>
<P>Return a list of character strings representing subkeys of the current key.</P>
<P></P>
<B><DL>GetValues((out)</B>@Values<B>)</DL>
<P></P>
<DL>Save(</B>$filename<B>)</B>
<DT>$filename</DT>
<DD>File to save the current hive of the registry to.</DD>
</DL>
<P>Save registry from current location. Set the security attributes of the file to the </P>
<P></P>
<B><DL>Load(</B> $subkey, $filename<B>)
</B>
<DT>$subkey </DT>
<DD>The subkey to load the file into</DD>
<DT>$filename </DT>
<DD>The file to load into the current key.</DD>
</DL>
<P>Load a registry file.</P>
<P><A NAME="registry_examples"></A><A HREF="#Registry"></A><B>Example</P>
</B><PRE>
       use Win32::Registry;
       $HKEY_LOCAL_MACHINE-&gt;Open("MyKey", $NewObj) || die $!;
       $NewObj-&gt;SetValue("MySubKey", REG_SZ, 5);</PRE>
<P><HR></P>
<H3><A NAME="NetAdmin"></A><A HREF="#contents"></A>Win32::NetAdmin</H3>

<UL>
<LI><A HREF="#netadmin_functions">Functions</A> </LI>
<LI><A HREF="#netadmin_examples">Examples</A></LI></UL>

<P><A NAME="netadmin_functions"></A><A HREF="#NetAdmin"></A><B>Functions</P>
<DL>GetDomainController(</B>$server,$domain,<B>(out)</B>returnedName<B>)</B>
<DT><B>GetAnyDomainController(</B>$server,$domain,<B>(out)</B>returnedName<B>)</B></DT>
<DT>$server </DT>
<DD>The server to request.</DD>
<DT>$domain </DT>
<DD>The windows domain name. </DD>
<B><DT>(out)</B>$returnedName </DT>
<DD>The result.</DD></DL>
<P>Return the name of the domain controller for server</P>
<P></P>
<B><DL>UserCreate(</B>$server, $userName, $password,$passwordAge,$privilege,$homeDir, $comment, $flags, $scriptPath<B>)
</B>
<DT>$server </DT>
<DD>The name of the server </DD>
<DT>$userName</DT>
<DD>The name of the new user.</DD>
<DT>$password </DT>
<DD>The users password</DD>
<DT>$PasswordAge</DT>
<DD>Time before password expires.</DD>
<DT>$privilege </DT>
<DD>The Privileges of the new user(see below for options)</DD>
<DT>$homeDir </DT>
<DD>The home directory of the user.</DD>
<DT>$comment</DT>
<DD>A relevant comment about the user. </DD>
<DT>$flag</DT>
<DD>A flag controlling user creation (see below for options) </DD>
<DT>$scriptPath <DD>Pathname of the login script. Creates a user on server with password, passwordAge, privilege,homeDir, comment, flags, and scriptPath</DT>
<DT>$Privilege options:</DT>
<UL>
<DT><LI>USER_PRIV_MASK</LI></DT>
<DT><LI>USER_PRIV_GUEST </LI></DT>
<DT><LI>USER_PRIV_USER</LI></DT>
<DT><LI>USER_PRIV_ADMIN</LI></DT>
</DL></UL>
<DT>$flag options:</DT>
<UL>
<DT><LI>UF_TEMP_DUPLICATE_ACCOUNT</LI></DT>
<DT><LI>UF_NORMAL_ACCOUNT</LI></DT>
<DT><LI>UF_INTERDOMAIN_TRUST_ACCOUNT</LI></DT>
<DT><LI>UF_WORKSTATION_TRUST_ACCOUNT </LI></DT>
<DT><LI>UF_SERVER_TRUST_ACCOUNT</LI></DT>
<DT><LI>UF_MACHINE_ACCOUNT_MASK</LI></DT>
<DT><LI>UF_ACCOUNT_TYPE_MASK</LI></DT>
<DT><LI>UF_DONT_EXPIRE_PASSWD</LI></DT>
<DT><LI>UF_SETTABLE_BITS</LI></DT>
<DT><LI>UF_SCRIPT </LI></DT>
<DT><LI>UF_ACCOUNTDISABLE</LI></DT>
<DT><LI>UF_HOMEDIR_REQUIRED</LI></DT>
<DT><LI>UF_LOCKOUT</LI></DT>
<DT><LI>UF_PASSWD_NOTREQD</LI></DT>
<DT><LI>UF_PASSWD_CANT_CHANGE</LI></DT></UL>
<P></P>
<P></P>
<B>UserDelete(</B>$server, $user<B>)</B>
<DT>$server</DT>
<DD>The name of the server.</DD>
<DT>$user</DT>
<DD>The name of the user to delete.</DD>
<DT>Deletes a user from server</DT>
<P></P>
<DL><B>UserGetAttributes(</B>$server, $userName, $password, $passwordAge,$privilege,$homeDir, $comment, $flags, $scriptPath<B>)</B>
<DT>$server</DT>
<DD>The name of the server.</DD>
<DT>$userName</DT>
<DD>The name of the user.</DD>
<DT>$password </DT>
<DD>The user's password.</DD>
<DT>$passwordAge </DT>
<DD>The time before the password expires.</DD>
<DT>$privilege </DT>
<DD>The user's privilege.</DD>
<DT>$homeDir </DT>
<DD>The user's home directory.</DD>
<DT>$comment</DT>
<DD>The user's comment.</DD>
<DT>$flags</DT>
<DD>Flags re: user's account.</DD>
<DT>$scriptPath </DT>
<DD>Pathname of user's login script. </DD>
</DL>
<P>Gets password, passwordAge, privilege, homeDir, comment, flags,and scriptPath for user. </P>
<P></P>
<B><DL>UserSetAttributes(</B>$server, $userName, $password, $passwordAge,$privilege, $homeDir, $comment, $flags, $scriptPath<B>)</B>
<DT>$server </DT>
<DD>The name of the server. </DD>
<DT>$userName </DT>
<DD>The name of the user. </DD>
<DT>$password </DT>
<DD>The user's password. </DD>
<DT>$passwordAge </DT>
<DD>The time before the password expires . </DD>
<DT>$privilege </DT>
<DD>The user's privilege. </DD>
<DT>$homeDir </DT>
<DD>The user's home directory. </DD>
<DT>$comment </DT>
<DD>The user's comment. </DD>
<DT>$flags </DT>
<DD>Flags re: user's account </DD>
<DT>$scriptPath </DT>
<DD>Pathname of user's login script </DD>
</DL>
<P>Sets password, passwordAge, privilege, homeDir, comment, flags,and scriptPath for user </P>
<P></P>
<B><DL>LocalGroupCreate(</B>$server, $group, $comment<B>)<BR>
GroupCreate(</B>$server, $group, $comment<B>)</B>
<DT>$server </DT>
<DD>The name of the server. </DD>
<DT>$group </DT>
<DD>The name of the group to create. </DD>
<DT>$comment </DT>
<DD>A relevant comment for the group</DD>
</DL>
<P>Creates a group</P>
<P></P>
<B><DL>LocalGroupDelete(</B>$server, $group<B>)<BR>
GroupDelete(</B>$server, $group<B>)</B>
<DT>$server </DT>
<DD>The name of the server. </DD>
<DT>$group </DT>
<DD>The name of the group to delete.</DD>
</DL>
<P>Delete a group from the server.</P>
<P></P>
<B><DL>LocalGroupGetAttributes(</B>$server, $groupName, <B>(out)</B>$comment<B>)<BR>
GroupGetAttributes(</B>$server, $groupName,<B>(out)</B>comment<B>)</B>
<DT>$server </DT>
<DD>The name of the server. </DD>
<DT>$groupName </DT>
<DD>The name of the group </DD>
<B><DT>(out)</B> $comment </DT>
<DD>Contains the comment for the group after the call returns. </DD>
</DL>
<P>Gets the comment for the group $group on the server $server. </P>
<P></P>
<B><DL>LocalGroupSetAttributes(</B>$server, $groupName, $comment<B>)<BR>
GroupSetAttributes(</B>$server, $groupName, $comment<B>)</B>
<DT>$server </DT>
<DD>The name of the server. </DD>
<DT>$groupName </DT>
<DD>The name of the group. </DD>
<DT>$comment </DT>
<DD>The comment to set for the group.</DD>
</DL>
<P>Sets the comment for the group $groupName on the server $server. </P>
<P></P>
<B><DL>LocalGroupAddUsers(</B>$server, $groupName, $users<B>)<BR>
GroupAddUsers(</B>$server, $groupName, @users<B>)</B>
<DT>$server </DT>
<DD>The name of the server.</DD>
<DT>$groupName </DT>
<DD>The name of the group.</DD>
<DT>@users </DT>
<DD>The names of the users to add.</DD>
</DL>
<P>Adds users to a group.</P>
<P></P>
<B><DL>LocalGroupDeleteUsers(</B>$server, $groupName, @users<B>)<BR>
GroupDeleteUsers(</B>$server, $groupName, @users<B>)</B>
<DT>$server</DT>
<DD>The name of the server.</DD>
<DT>$groupName</DT>
<DD>The name of the group.</DD>
<DT>@users</DT>
<DD>A list of user names to delete.</DD>
</DL>
<P>Deletes a list of users from a group. </P>
<P></P>
<B><DL>LocalGroupIsMember(</B>$server, $groupName,$user<B>)<BR>
GroupIsMember(</B>$server, $groupName, $user<B>)</B>
<DT>$server </DT>
<DD>Name of the server to query. </DD>
<DT>$groupName </DT>
<DD>Name of the group. </DD>
<DT>$user </DT>
<DD>name of the user, whose membership is being tested. </DD>
</DL>
<P>Returns TRUE if $user is a member of $groupName </P>
<P></P>
<B><DL>LocalGroupGetMembers(</B>$server, $groupName, <B>(out)</B>\@userArray<B>)<BR>
GroupGetMembers(</B>$server, $groupName,<B>(out)</B>\@userArray<B>)</B>
<DT>$server </DT>
<DD>The name of the server. </DD>
<DT>$groupName </DT>
<DD>The name of the group. </DD>
<B><DT>(out)</B>\@userArray </DT>
<DD>A reference to an arry of users.</DD>
</DL>
<P>Fills userArray with the members of groupName</P>
<P><A NAME="netadmin_examples"></A><A HREF="#NetAdmin"></A><B>Example</P>
</B><PRE>
       use Win32::NetAdmin;
       # set info for the user.
       $userName = 'TestUser';
       $password = '';
       $passwordAge = 0;
       $privilege = USER_PRIV_USER;
       $homeDir = 'c:\\';
       $comment = 'This is a test user';
       $flags = UF_SCRIPT;
       $scriptpath = 'C:\\';
       $groupName = 'TestGroup';
       $groupComment = "This is a test group";
       Win32::NetAdmin::UserCreate('', $userName,
                              $password, 
                              $passwordAge, 
                              $privilege, 
                              $homeDir, 
                              $comment, 
                              $flags,
                              $scriptpath) || print "not ";
   
       Win32::NetAdmin::UserGetAttributes('',$userName, 
                              $Getpassword, 
                              $GetpasswordAge, 
                              $Getprivilege, 
                              $GethomeDir,
                              $Getcomment, 
                              $Getflags, 
                              $Getscriptpath) || warn();

       ($password eq $Getpassword) || warn();
       ($passwordAge == $GetpasswordAge) || warn();
       ($homeDir eq $GethomeDir) || warn();
       ($comment eq $Getcomment) || warn();
       ($flags == ($Getflags&amp;USER_PRIV_MASK)) || warn();
       ($scriptpath eq $scriptpath) || warn();</PRE>
<H4>Implementation Note</H4>
<P>The Win32::NetAdmin module is to allow control over the Windows NT users and group functions. These are not available on Windows 95. The module will not load on a Windows95 machine. </P>
<P><HR></P>
<H3><A NAME="File"></A><A HREF="#contents"></A>Win32::File</H3>

<UL>
<LI><A HREF="#file_functions">Functions</A> </LI>
<LI><A HREF="#file_examples">Examples</A></LI></UL>

<P><A NAME="file_functions"></A><A HREF="#File"></A><B>Functions</P>
<DL>GetAttributes(</B> $filename,<B>(out)</B>$FileAttributes<B>)</B>
<DT>$filename </DT>
<DD>Name of the file. </DD>
<B><DT>(out)</B>$FileAttributes </DT>
<DD>Attributes of the file.</DD>
</DL>
<P>$FileAttributes contains one or more of the following values:</P>
<UL>
<LI>ARCHIVE </LI>
<LI>DIRECTORY </LI>
<LI>HIDDEN, </LI>
<LI>NORMAL </LI>
<LI>READONLY </LI>
<LI>SYSTEM</LI></UL>
<P></P>
<B><DL>SetFileAttributes(</B>$filename, $FileAttributes <B>)</B>
<DT>$filename </DT>
<DD>Name of the file. </DD>
<DT>$FileAttributes </DT>
<DD>Attributes of the file.</DD>
</DL>
<P>Set the attributes for the listed file.</P>
<P><A NAME="file_examples"></A><A HREF="#File"></A><B>Example</P>
</B><PRE>
       use Win32::File;
       Win32::File::GetAttributes("myfile.txt", $Attributes) || die $!;
       Win32::File::SetAttributes("myfile.txt", ($Attributes | READONLY)) || die $!; </PRE>
<P><HR></P>
<H3><A NAME="Service"></A><A HREF="#contents"></A>Win32::Service</H3>

<UL>
<LI><A HREF="#service_functions">Functions</A> </LI>
<LI><A HREF="#service_examples">Examples</A></LI></UL>

<P><A NAME="service_functions"></A><A HREF="#Service"></A><B>Functions</P>
<DL>StartService(</B>$hostname, $servicename<B>)</B>
<DT>$hostname </DT>
<DD>Name of the host.If NULL, then the localhost. </DD>
<DT>$servicename </DT>
<DD>String containing the name of the service to start.</DD>
</DL>
<P>Starts a service. This service must be registered with the Service Control Manager . </P>
<P></P>
<B><DL>StopService(</B>$hostname, $servicename<B>)</B>
<DT>$hostname </DT>
<DD>Name of the host. If NULL, then the localhost. </DD>
<DT>$servicename </DT>
<DD>String containing the name of the service to stop.</DD>
</DL>
<P>Stops a service. </P>
<P></P>
<B><DL>GetStatus(</B>$hostname, $servicename,<B>(out)</B>\%status<B>)</B>
<DT>$hostname </DT>
<DD>Name of the host. If NULL, then the localhost. </DD>
<DT>$servicename </DT>
<DD>Name of the service </DD>
<B><DT>(out)</B>\%status </DT>
<DD>Scalar containing the result of the GetStatus call.</DD>
</DL>
<P>The GetStatus call returns the status as a hash reference in $status.<BR>
The keys of this hash are:</P>

<UL>
<LI>ServiceType </LI>
<LI>CurrentState </LI>
<LI>ControlsAccepted </LI>
<LI>Win32ExitCode </LI>
<LI>ServiceSpecificExitCode </LI>
<LI>CheckPoint </LI>
<LI>WaitHint</LI></UL>

<P>These keys correspond to the members of the SERVICE_STATUS structure. (refer to the Win32 Programmer's Reference V4). </P>
<B><DL>PauseService(</B>$hostname ,$servicename<B>)</B><BR>
<B>ResumeService(</B>$hostname ,$servicename<B>)</B>
<DT>$hostname </DT>
<DD>Name of the host. If NULL, then the localhost. </DD>
<DT>$servicename </DT>
<DD>Name of the service.</DD>
</DL>
<P>This Pair of calls pause and resume services. (Service must be able to pause.) </P>
<P></P>
<B><DL>GetServices(</B>$hostname,<B>(out)</B>\%list<B>)</B>
<DT>$hostname </DT>
<DD>Name of the host. If NULL, then the localhost. </DD>
<B><DT>(out)</B>\%list </DT>
<DD>Reference to hold the list returned from EnumServices.</DD>
</DL>
<P>GetServices returns a list of available services in @$list. </P>
<P><A NAME="service_examples"></A><A HREF="#Service"></A><B>Example</P>
</B><PRE>
        use Win32::Service;

        Win32::Service::GetServices('', \%list) || die $!;
        print "Display Name = Service Name\n";
        foreach $key (keys %list)
        {
            print $key, '=', $list{$key}, "\n";
        }

        print "\n\n\n";

        Win32::Service::GetStatus('', 'Messenger', \%status) || die $!;
        foreach $key (keys %status)
        {
            print $key, '=', $status{$key}, "\n";
        }</PRE>
<P><HR></P>
<H3><A NAME="NetResource"></A><A HREF="#contents"></A>Win32::NetResource</H3>

<UL>
<LI><A HREF="#netres_data">Data</A> </LI>
<LI><A HREF="#netres_functions">Functions</A> </LI>
<LI><A HREF="#netres_examples">Examples</A> </LI></UL>

<P><A NAME="netres_data"></A><A HREF="#NetResource"></A><B>Data</P>
<P>%SHARE_INFO</B><BR>
The ShareInfo hash is used to pass information to the NetResource functions concerned with shares.</P>
<PRE>
   KEY                    VALUE
'netname'       =&gt; Name of the share.
'type'          =&gt; Type of share.
'remark'        =&gt; A string comment.
'permissions'   =&gt; Permissions value
'maxusers'      =&gt; The max # of users.
'current-users' =&gt; The current # of users.
'path'          =&gt; The path of the share.
'passwd'        =&gt; A password if one is req'd</PRE>
<B><P>NETRESOURCE </P>
</B><PRE>
   KEY                      VALUE
'Scope'         =&gt; Scope of an Enumeration. See Scopes below.
'Type'          =&gt; The type of resource to Enum. See Types below.
'DisplayType'   =&gt; The way the resource should be displayed.See Display below.
'Usage'         =&gt; Specifies the Resources usage: see Usage below.
'LocalName'     =&gt; Name of the local device the resource is connected to.
'RemoteName'    =&gt; The network name of the resource.
'Comment'       =&gt; A string comment.
'Provider'      =&gt; Name of the provider of the resource.

Scope values:
RESOURCE_CONNECTED   The resource is already connected.
RESOURCE_REMEMBERED  The resource is reconnected each time the user logs on.
RESOURCE_GLOBALNET   The resource is available to the entire network.

Type values:
RESOURCETYPE_ANY     All resources
RESOURCETYPE_DISK    Disk resources
RESOURCETYPE_PRINT   Print resources

Display Type:
RESOURCEDISPLAYTYPE_DOMAIN    The object should be displayed as a domain. 
RESOURCEDISPLAYTYPE_SERVER    The object should be displayed as a server
RESOURCEDISPLAYTYPE_SHARE     The object should be displayed as a sharepoint.
RESOURCEUSAGE_CONNECTABLE     The resource can be connected to a local device.
RESOURCEUSAGE_CONTAINER       The resource contains more resources.</PRE>
<P><A NAME="netres_functions"></A><A HREF="#NetResource"></A><B>Functions</P>
<P></P>
<DL>GetSharedResources((out)</B>\@Resources,dwType<B>)
<DT>(out)</B>\@Resources </DT>
<DD>A list of references to %NETRESOURCE hashes. </DD>
<DT>DwType </DT>
<DD>The type of the enumeration.</DD>
</DL>
<P>Creates a list in @Resources of %NETRESOURCE hash references.This list contains all network resources. (Shared printers, disks, etc). </P>
<P></P>
<B><DL>AddConnection(</B>\%NETRESOURCE,$Password,$UserName,$Connection<B>)</B>
<DT>\%NETRESOURCE </DT>
<DD>A hash representing the connection to make. </DD>
<DT>$Password </DT>
<DD>The password of the user making the connection </DD>
<DT>$UserName </DT>
<DD>The username of the user. </DD>
<DT>%Connection </DT>
<DD>flag for connection</DD>
</DL>
<P>Makes a connection to a network resource specified by %NETRESOURCE, for the user $user.The $Connection flag determines whether the connection should be remembered for the user, for all logins. </P>
<P></P>
<B><DL>CancelConnection(</B>$Name,$Connection,$Force<B>)</B>
<DT>$Name </DT>
<DD>The name of the local device the resource is connected to. </DD>
<DT>$Connection </DT>
<DD>Type of connection. </DD>
<DT>$Force </DT>
<DD>Boolean: whether or not to force the connection. </DD>
</DL>
<P>Cancels a connection to a network resource connected to local device $name.$Connection is either 1 - persistent connection or 0, non-persistent. </P>
<P></P>
<B><DL>WNetGetLastError((out)</B>$ErrorCode<B>(out)</B>,$Description,<B>(out)</B>$Name<B>)
<DT>(out)</B>$ErrorCode </DT>
<DD>The error code number. </DD>
<B><DT>(out)</B>$Description </DT>
<DD>A description of the error. </DD>
<B><DT>(out)</B>$Name </DT>
<DD>The name of the error.</DD>
</DL>
<P>Gets the Extended Network Error. This is only applicable if Win32::GetLastError() returns ERROR_EXTENDED_ERROR.</P>
<P></P>
<B><DL>GetError((out)</B>$ErrorCode<B>)
<DT>(out)</B>$ErrorCode</DT>
<DD>last error caused by a Win32 Network call.</DD>
</DL>
<P>Gets the last Error for a Win32::NetResource call. </P>
<P></P>
<B><DL>GetUNCName((out)</B>$UNCName, $LocalPath<B>)
<DT>(out)</B>$UNCName </DT>
<DD>The UNC name of the network connection. </DD>
<DT>$LocalPath </DT>
<DD>The name of the local path.</DD>
</DL>
<P>Returns the UNC name of the disk share connected to $LocalPath in $UNCName.<BR>
NOTE: The $servername arg is optional for all of the Share calls. </P>
<P></P>
<B><DL>NetShareAdd(</B>\%SHARE,$parm_err,$servername<B>)</B>
<DT>%SHARE </DT>
<DD>A ShareInfo hash describing the share. </DD>
<B><DT>(out)</B>$parm_err </DT>
<DD>An error value describing any errors that occurred. </DD>
<DT>$servername </DT>
<DD>Name of the server.</DD>
</DL>
<P>Offer a disk resource for sharing on the network. </P>
<P></P>
<B><DL>NetShareCheck(</B>$device,<B>(out)</B>$type,$servername<B>)</B>
<DT>$device </DT>
<DD>Name of the device to be checked for shared access. </DD>
<B><DT>(out)</B>$type </DT>
<DD>On return, contains the type of share. </DD>
<DT>$servername </DT>
<DD>Name of the server.</DD>
</DL>
<P>Check if a share is available for connection. The value in $type is only valid if the funtion returns a true value (non-zero).</P>
<P></P>
<B><DL>NetShareDel(</B> $netname, $servername<B>)</B>
<DT>$netname </DT>
<DD>The name of the share. </DD>
<DT>$servername </DT>
<DD>The machine offering the share.</DD>
</DL>
<P>Remove a share from a machine's list of shares. </P>
<P></P>
<B><DL>NetShareGetInfo(</B>$netname, <B>(out)</B>\%SHARE,$servername<B>)</B>
<DT>$netname </DT>
<DD>The network name of the share. </DD>
<B><DT>(out)</B> </DT>
<DD>\%SHARE The SHARE_INFO hash describing the share. </DD>
<DT>$servername </DT>
<DD>The server.</DD>
</DL>
<P>Get the %SHARE_INFO information about the share $netname on the server $servername. </P>
<P></P>
<B><DL>NetShareSetInfo(</B>$netname,\%SHARE,<B>(out)</B>$parm_err,$servername<B>)</B>
<DT>$netname </DT>
<DD>The network name of the share. </DD>
<DT>\%SHARE </DT>
<DD>The SHARE_INFO hash describing the share. </DD>
<B><DT>(out)</B>$parm_err </DT>
<DD>The error status. </DD>
<DT>$servername </DT>
<DD>The name of the server.</DD>
</DL>
<P>Set the information for share $netname.</P>
<P><A NAME="netres_examples"></A><A HREF="#NetResource"></A><B>Example</P>
</B><PRE>
       use Win32::NetResource;
       use Win32;
       $ShareInfo = 
       {
           'path' =&gt; 'e:\\temp', 
           'netname' =&gt; "myshare",
           'remark' =&gt; "This mine, leave it alone",
           'passwd' =&gt; "", 
           'current-users' =&gt; 0, 
           'permissions' =&gt; 0,
           'maxusers' =&gt; 10, 
           'type' =&gt; 10
       };
     
       Win32::NetResource::NetShareAdd($ShareInfo, $parm) || warn();
       $NewShare = {};
       Win32::NetResource::NetShareGetInfo("Temp", $NewShare) || warn();
       $Aref=[];
       Win32::NetResource::GetSharedResources($Aref, 0);
       # try to connect to the Temp share.
       # Find the NETRESOURCE information for the Temp share.
       foreach $href (@$Aref)
       { 
           $myRef = $href if($href-&gt;{'RemoteName'} =~ /Temp/);
       }
       $myRef-&gt;{'LocalName'} = "Z:";
       Win32::NetResource::AddConnection($myRef, $passwd, $user, 0);
       Win32::NetResource::GetUNCName($UNCName, "Z:");
       print "UNCName of the share is $UNCName\n");
       Win32::NetResource::CancelConnection("Z:", 0, 1);
       Win32::NetResource::NetShareDel("Temp") || print "not "; </PRE>
<P><HR></P>
<P><A HREF="win32ext.html">Win32 Extensions</A>
<P><A HREF="#contents">Table of Contents</A>
<P><A HREF="http://www.ActiveWare.com">ActiveWare</A></P></BODY>
</HTML>
