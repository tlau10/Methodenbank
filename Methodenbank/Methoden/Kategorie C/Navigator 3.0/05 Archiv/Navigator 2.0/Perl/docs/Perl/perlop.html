<!-- $Id$ -->
<HTML><HEAD>
<CENTER><TITLE>perlop</TITLE>
</HEAD>
<BODY></CENTER><p><hr>

<H1> 
<A NAME="perlop_name_0">
NAME</A>
</H1>
perlop - Perl operators and precedence
<p><p><hr>

<H1> 
<A NAME="perlop_synopsis_0">
SYNOPSIS</A>
</H1>
Perl operators have the following associativity and precedence,
listed from highest precedence to lowest.  Note that all operators
borrowed from C keep the same precedence relationship with each other,
even where C's precedence is slightly screwy.  (This makes learning
Perl easier for C folks.)  With very few exceptions, these all 
operate on scalar values only, not array values.
<p><UL><LI>    left	terms and list operators (leftward)</LI>
<LI>    left	-></LI>
<LI>    nonassoc	++ --</LI>
<LI>    right	**</LI>
<LI>    right	! ~ \ and unary + and -</LI>
<LI>    left	=~ !~ </LI>
<LI>    left	* / % x</LI>
<LI>    left	+ - .</LI>
<LI>    left	<< >></LI>
<LI>    nonassoc	named unary operators</LI>
<LI>    nonassoc	< > <= >= lt gt le ge</LI>
<LI>    nonassoc	== != <=> eq ne cmp</LI>
<LI>    left	&</LI>
<LI>    left	| ^</LI>
<LI>    left	&&</LI>
<LI>    left	||</LI>
<LI>    nonassoc	..</LI>
<LI>    right	?:</LI>
<LI>    right	= += -= *= etc.</LI>
<LI>    left	, =></LI>
<LI>    nonassoc	list operators (rightward)</LI>
<LI>    right	not</LI>
<LI>    left	and</LI>
<LI>    left	or xor</LI>
</UL>
<p>In the following sections, these operators are covered in precedence order.
<p><p><hr>

<H1> 
<A NAME="perlop_description_0">
DESCRIPTION</A>
</H1>
<p>
<H2> 
<A NAME="perlop_terms_0">
Terms and List Operators (Leftward)</A>
</H2>
Any TERM is of highest precedence of Perl.  These includes variables,
quote and quotelike operators, any expression in parentheses,
and any function whose arguments are parenthesized.  Actually, there
aren't really functions in this sense, just list operators and unary
operators behaving as functions because you put parentheses around
the arguments.  These are all documented in the <EM>perlfunc</EM>  manpage
.
<p>If any list operator (<EM>print()</EM>, etc.) or any unary operator (<EM>chdir()</EM>, etc.)
is followed by a left parenthesis as the next token, the operator and
arguments within parentheses are taken to be of highest precedence,
just like a normal function call.
<p>In the absence of parentheses, the precedence of list operators such as
<CODE>print</CODE>, <CODE>sort</CODE>, or <CODE>chmod</CODE> is either very high or very low depending on
whether you look at the left side of operator or the right side of it.
For example, in
<p>
<XMP>
    @ary = (1, 3, sort 4, 2);
    print @ary;         # prints 1324

</XMP>
<p>the commas on the right of the sort are evaluated before the sort, but
the commas on the left are evaluated after.  In other words, list
operators tend to gobble up all the arguments that follow them, and
then act like a simple TERM with regard to the preceding expression.
Note that you have to be careful with parens:
<p>
<XMP>
    # These evaluate exit before doing the print:
    print($foo, exit);  # Obviously not what you want.
    print $foo, exit;   # Nor is this.
    # These do the print before evaluating exit:
    (print $foo), exit; # This is what you want.
    print($foo), exit;  # Or this.
    print ($foo), exit; # Or even this.

</XMP>
<p>Also note that
<p>
<XMP>
    print ($foo & 255) + 1, "\n";

</XMP>
<p>probably doesn't do what you expect at first glance.  See 

<A HREF="perlop.html#perlop_named_0"><EM>Named Unary Operators</EM></A>
 for more discussion of this.
<p>Also parsed as terms are the <CODE>do {}</CODE> and <CODE>eval {}</CODE> constructs, as
well as subroutine and method calls, and the anonymous 
constructors <CODE>[]</CODE> and <CODE>{}</CODE>.
<p>See also 
<A HREF="perlop.html#perlop_quote_0"><EM>Quote and Quotelike Operators</EM></A>
 toward the end of this section,
as well as <EM>O Operators''</EM>.
<p>
<H2> 
<A NAME="perlop_the_0">
The Arrow Operator</A>
</H2>
Just as in C and C++, ``<CODE>-&gt;</CODE>'' is an infix dereference operator.  If the
right side is either a <CODE>[...]</CODE> or <CODE>{...}</CODE> subscript, then the left side
must be either a hard or symbolic reference to an array or hash (or
a location capable of holding a hard reference, if it's an lvalue (assignable)).
See the <EM>perlref</EM>  manpage
.
<p>Otherwise, the right side is a method name or a simple scalar variable
containing the method name, and the left side must either be an object
(a blessed reference) or a class name (that is, a package name).
See the <EM>perlobj</EM>  manpage
.
<p>
<H2> 
<A NAME="perlop_autoincrement_0">
Autoincrement and Autodecrement</A>
</H2>
``++'' and ``--'' work as in C.  That is, if placed before a variable, they
increment or decrement the variable before returning the value, and if
placed after, increment or decrement the variable after returning the value.
<p>The autoincrement operator has a little extra built-in magic to it.  If
you increment a variable that is numeric, or that has ever been used in
a numeric context, you get a normal increment.  If, however, the
variable has only been used in string contexts since it was set, and
has a value that is not null and matches the pattern
<CODE>/^[a-zA-Z]*[0-9]*$/</CODE>, the increment is done as a string, preserving each
character within its range, with carry:
<p>
<XMP>
    print ++($foo = '99');      # prints '100'
    print ++($foo = 'a0');      # prints 'a1'
    print ++($foo = 'Az');      # prints 'Ba'
    print ++($foo = 'zz');      # prints 'aaa'

</XMP>
<p>The autodecrement operator is not magical.
<p>
<H2> 
<A NAME="perlop_exponentiation_0">
Exponentiation</A>
</H2>
Binary ``**'' is the exponentiation operator.  Note that it binds even more
tightly than unary minus, so -2**4 is -(2**4), not (-2)**4. (This is
implemented using C's pow(3) function, which actually works on doubles
internally.)
<p>
<H2> 
<A NAME="perlop_symbolic_0">
Symbolic Unary Operators</A>
</H2>
Unary ``!'' performs logical negation, i.e. ``not''.  See also <CODE>not</CODE> for a lower
precedence version of this.
<p>Unary ``-'' performs arithmetic negation if the operand is numeric.  If
the operand is an identifier, a string consisting of a minus sign
concatenated with the identifier is returned.  Otherwise, if the string
starts with a plus or minus, a string starting with the opposite sign
is returned.  One effect of these rules is that <CODE>-bareword</CODE> is equivalent
to <CODE>``-bareword''</CODE>.
<p>Unary ``~'' performs bitwise negation, i.e. 1's complement.
<p>Unary ``+'' has no effect whatsoever, even on strings.  It is useful
syntactically for separating a function name from a parenthesized expression
that would otherwise be interpreted as the complete list of function
arguments.  (See examples above under 
<A HREF="perlop.html#perlop_terms_0"><EM>Terms and List Operators (Leftward)</EM></A>
.)
<p>Unary ``\'' creates a reference to whatever follows it.  See the <EM>perlref</EM>  manpage
.
Do not confuse this behavior with the behavior of backslash within a
string, although both forms do convey the notion of protecting the next
thing from interpretation.
<p>
<H2> 
<A NAME="perlop_binding_0">
Binding Operators</A>
</H2>
Binary ``=~'' binds a scalar expression to a pattern match.  Certain operations
search or modify the string <STRONG>$_</STRONG> by default.  This operator makes that kind
of operation work on some other string.  The right argument is a search
pattern, substitution, or translation.  The left argument is what is
supposed to be searched, substituted, or translated instead of the default
<STRONG>$_</STRONG>.  The return value indicates the success of the operation.  (If the
right argument is an expression rather than a search pattern,
substitution, or translation, it is interpreted as a search pattern at run
time.  This is less efficient than an explicit search, since the pattern
must be compiled every time the expression is evaluated--unless you've
used <CODE>/o</CODE>.)
<p>Binary ``!~'' is just like ``=~'' except the return value is negated in
the logical sense.
<p>
<H2> 
<A NAME="perlop_multiplicative_0">
Multiplicative Operators</A>
</H2>
Binary ``*'' multiplies two numbers.
<p>Binary ``/'' divides two numbers.
<p>Binary ``%'' computes the modulus of the two numbers.
<p>Binary ``x'' is the repetition operator.  In a scalar context, it
returns a string consisting of the left operand repeated the number of
times specified by the right operand.  In a list context, if the left
operand is a list in parens, it repeats the list.
<p>
<XMP>
    print '-' x 80;             # print row of dashes
    print "\t" x ($tab/8), ' ' x ($tab%8);      # tab over
    @ones = (1) x 80;           # a list of 80 1's
    @ones = (5) x @ones;        # set all elements to 5

</XMP>
<p>
<H2> 
<A NAME="perlop_additive_0">
Additive Operators</A>
</H2>
Binary ``+'' returns the sum of two numbers.
<p>Binary ``-'' returns the difference of two numbers.
<p>Binary ``.'' concatenates two strings.
<p>
<H2> 
<A NAME="perlop_shift_0">
Shift Operators</A>
</H2>
Binary ``&lt;&lt;'' returns the value of its left argument shifted left by the
number of bits specified by the right argument.  Arguments should be 
integers.
<p>Binary ``&gt;&gt;'' returns the value of its left argument shifted right by the
number of bits specified by the right argument.  Arguments should be 
integers.
<p>
<H2> 
<A NAME="perlop_named_0">
Named Unary Operators</A>
</H2>
The various named unary operators are treated as functions with one
argument, with optional parentheses.  These include the filetest
operators, like <CODE>-f</CODE>, <CODE>-M</CODE>, etc.  See the <EM>perlfunc</EM>  manpage
.
<p>If any list operator (<EM>print()</EM>, etc.) or any unary operator (<EM>chdir()</EM>, etc.)
is followed by a left parenthesis as the next token, the operator and
arguments within parentheses are taken to be of highest precedence,
just like a normal function call.  Examples:
<p>
<XMP>
    chdir $foo    || die;       # (chdir $foo) || die
    chdir($foo)   || die;       # (chdir $foo) || die
    chdir ($foo)  || die;       # (chdir $foo) || die
    chdir +($foo) || die;       # (chdir $foo) || die

</XMP>
<p>but, because * is higher precedence than ||:
<p>
<XMP>
    chdir $foo * 20;    # chdir ($foo * 20)
    chdir($foo) * 20;   # (chdir $foo) * 20
    chdir ($foo) * 20;  # (chdir $foo) * 20
    chdir +($foo) * 20; # chdir ($foo * 20)
    rand 10 * 20;       # rand (10 * 20)
    rand(10) * 20;      # (rand 10) * 20
    rand (10) * 20;     # (rand 10) * 20
    rand +(10) * 20;    # rand (10 * 20)

</XMP>
<p>See also <EM>``Terms and List Operators (Leftward)''</EM>.
<p>
<H2> 
<A NAME="perlop_relational_0">
Relational Operators</A>
</H2>
Binary ``&lt;'' returns true if the left argument is numerically less than
the right argument.
<p>Binary ``&gt;'' returns true if the left argument is numerically greater
than the right argument.
<p>Binary ``&lt;='' returns true if the left argument is numerically less than
or equal to the right argument.
<p>Binary ``&gt;='' returns true if the left argument is numerically greater
than or equal to the right argument.
<p>Binary ``lt'' returns true if the left argument is stringwise less than
the right argument.
<p>Binary ``gt'' returns true if the left argument is stringwise greater
than the right argument.
<p>Binary ``le'' returns true if the left argument is stringwise less than
or equal to the right argument.
<p>Binary ``ge'' returns true if the left argument is stringwise greater
than or equal to the right argument.
<p>
<H2> 
<A NAME="perlop_equality_0">
Equality Operators</A>
</H2>
Binary ``=='' returns true if the left argument is numerically equal to
the right argument.
<p>Binary ``!='' returns true if the left argument is numerically not equal
to the right argument.
<p>Binary ``&lt;=&gt;'' returns -1, 0, or 1 depending on whether the left
argument is numerically less than, equal to, or greater than the right
argument.
<p>Binary ``eq'' returns true if the left argument is stringwise equal to
the right argument.
<p>Binary ``ne'' returns true if the left argument is stringwise not equal
to the right argument.
<p>Binary ``cmp'' returns -1, 0, or 1 depending on whether the left argument is stringwise
less than, equal to, or greater than the right argument.
<p>
<H2> 
<A NAME="perlop_bitwise_0">
Bitwise And</A>
</H2>
Binary ``&amp;'' returns its operators ANDed together bit by bit.
<p>
<H2> 
<A NAME="perlop_bitwise_1">
Bitwise Or and Exclusive Or</A>
</H2>
Binary ``|'' returns its operators ORed together bit by bit.
<p>Binary ``^'' returns its operators XORed together bit by bit.
<p>
<H2> 
<A NAME="perlop_c_style_0">
C-style Logical And</A>
</H2>
Binary ``&amp;&amp;'' performs a short-circuit logical AND operation.  That is,
if the left operand is false, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand if it
is evaluated.
<p>
<H2> 
<A NAME="perlop_c_style_1">
C-style Logical Or</A>
</H2>
Binary ``||'' performs a short-circuit logical OR operation.  That is,
if the left operand is true, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand if it
is evaluated.
<p>The <CODE>||</CODE> and <CODE>&amp;&amp;</CODE> operators differ from C's in that, rather than returning
0 or 1, they return the last value evaluated.  Thus, a reasonably portable
way to find out the home directory (assuming it's not ``0'') might be:
<p>
<XMP>
    $home = $ENV{'HOME'} || $ENV{'LOGDIR'} ||
        (getpwuid($<))[7] || die "You're homeless!\n";

</XMP>
<p>As more readable alternatives to <CODE>&amp;&amp;</CODE> and <CODE>||</CODE>, Perl provides ``and'' and
``or'' operators (see below).  The short-circuit behavior is identical.  The
precedence of ``and'' and ``or'' is much lower, however, so that you can
safely use them after a list operator without the need for
parentheses:
<p>
<XMP>
    unlink "alpha", "beta", "gamma"
            or gripe(), next LINE;

</XMP>
<p>With the C-style operators that would have been written like this:
<p>
<XMP>
    unlink("alpha", "beta", "gamma")
            || (gripe(), next LINE);

</XMP>
<p>
<H2> 
<A NAME="perlop_range_0">
Range Operator</A>
</H2>
Binary ``..'' is the range operator, which is really two different
operators depending on the context.  In a list context, it returns an
array of values counting (by ones) from the left value to the right
value.  This is useful for writing <CODE>for (1..10)</CODE> loops and for doing
slice operations on arrays.  Be aware that under the current implementation,
a temporary array is created, so you'll burn a lot of memory if you 
write something like this:
<p>
<XMP>
    for (1 .. 1_000_000) {
        # code
    } 

</XMP>
<p>In a scalar context, ``..'' returns a boolean value.  The operator is
bistable, like a flip-flop, and emulates the line-range (comma) operator
of <STRONG>sed</STRONG>, <STRONG>awk</STRONG>, and various editors.  Each ``..'' operator maintains its
own boolean state.  It is false as long as its left operand is false.
Once the left operand is true, the range operator stays true until the
right operand is true, <EM>AFTER</EM> which the range operator becomes false
again.  (It doesn't become false till the next time the range operator is
evaluated.  It can test the right operand and become false on the same
evaluation it became true (as in <STRONG>awk</STRONG>), but it still returns true once.
If you don't want it to test the right operand till the next evaluation
(as in <STRONG>sed</STRONG>), use three dots (``...'') instead of two.)  The right
operand is not evaluated while the operator is in the ``false'' state, and
the left operand is not evaluated while the operator is in the ``true''
state.  The precedence is a little lower than || and &amp;&amp;.  The value
returned is either the null string for false, or a sequence number
(beginning with 1) for true.  The sequence number is reset for each range
encountered.  The final sequence number in a range has the string ``E0''
appended to it, which doesn't affect its numeric value, but gives you
something to search for if you want to exclude the endpoint.  You can
exclude the beginning point by waiting for the sequence number to be
greater than 1.  If either operand of scalar ``..'' is a numeric literal,
that operand is implicitly compared to the <CODE>$.</CODE> variable, the current
line number.  Examples:
<p>As a scalar operator:
<p>
<XMP>
    if (101 .. 200) { print; }  # print 2nd hundred lines
    next line if (1 .. /^$/);   # skip header lines
    s/^/> / if (/^$/ .. eof()); # quote body

</XMP>
<p>As a list operator:
<p>
<XMP>
    for (101 .. 200) { print; } # print $_ 100 times
    @foo = @foo[$[ .. $#foo];   # an expensive no-op
    @foo = @foo[$#foo-4 .. $#foo];      # slice last 5 items

</XMP>
<p>The range operator (in a list context) makes use of the magical
autoincrement algorithm if the operands are strings.  You
can say
<p>
<XMP>
    @alphabet = ('A' .. 'Z');

</XMP>
<p>to get all the letters of the alphabet, or
<p>
<XMP>
    $hexdigit = (0 .. 9, 'a' .. 'f')[$num & 15];

</XMP>
<p>to get a hexadecimal digit, or
<p>
<XMP>
    @z2 = ('01' .. '31');  print $z2[$mday];

</XMP>
<p>to get dates with leading zeros.  If the final value specified is not
in the sequence that the magical increment would produce, the sequence
goes until the next value would be longer than the final value
specified.
<p>
<H2> 
<A NAME="perlop_conditional_0">
Conditional Operator</A>
</H2>
Ternary ``?:'' is the conditional operator, just as in C.  It works much
like an if-then-else.  If the argument before the ? is true, the
argument before the : is returned, otherwise the argument after the :
is returned.  For example:
<p>
<XMP>
    printf "I have %d dog%s.\n", $n, 
            ($n == 1) ? '' : "s";

</XMP>
<p>Scalar or list context propagates downward into the 2nd
or 3rd argument, whichever is selected.  
<p>
<XMP>
    $a = $ok ? $b : $c;  # get a scalar
    @a = $ok ? @b : @c;  # get an array
    $a = $ok ? @b : @c;  # oops, that's just a count!

</XMP>
<p>The operator may be assigned to if both the 2nd and 3rd arguments are
legal lvalues (meaning that you can assign to them):
<p>
<XMP>
    ($a_or_b ? $a : $b) = $c;

</XMP>
<p>This is not necessarily guaranteed to contribute to the readability of your program.
<p>
<H2> 
<A NAME="perlop_assignment_0">
Assignment Operators</A>
</H2>
``='' is the ordinary assignment operator.
<p>Assignment operators work as in C.  That is,
<p>
<XMP>
    $a += 2;

</XMP>
<p>is equivalent to
<p>
<XMP>
    $a = $a + 2;

</XMP>
<p>although without duplicating any side effects that dereferencing the lvalue
might trigger, such as from <EM>tie()</EM>.  Other assignment operators work similarly.  
The following are recognized: 
<p>
<PRE>
    **=    +=    *=    &amp;=    &lt;&lt;=    &amp;&amp;=
           -=    /=    |=    &gt;&gt;=    ||=
           .=    %=    ^=
                 x=

</PRE>
<p>Note that while these are grouped by family, they all have the precedence
of assignment.
<p>Unlike in C, the assignment operator produces a valid lvalue.  Modifying
an assignment is equivalent to doing the assignment and then modifying
the variable that was assigned to.  This is useful for modifying
a copy of something, like this:
<p>
<XMP>
    ($tmp = $global) =~ tr [A-Z] [a-z];

</XMP>
<p>Likewise,
<p>
<XMP>
    ($a += 2) *= 3;

</XMP>
<p>is equivalent to
<p>
<XMP>
    $a += 2;
    $a *= 3;

</XMP>
<p>
<H2> 
<A NAME="perlop_comma_0">
Comma Operator</A>
</H2>
Binary ``,'' is the comma operator.  In a scalar context it evaluates
its left argument, throws that value away, then evaluates its right
argument and returns that value.  This is just like C's comma operator.
<p>In a list context, it's just the list argument separator, and inserts
both its arguments into the list.
<p>The =&gt; digraph is mostly just a synonym for the comma operator.  It's useful for
documenting arguments that come in pairs.  As of release 5.001, it also forces
any word to the left of it to be interpreted as a string.
<p>
<H2> 
<A NAME="perlop_list_0">
List Operators (Rightward)</A>
</H2>
On the right side of a list operator, it has very low precedence,
such that it controls all comma-separated expressions found there.
The only operators with lower precedence are the logical operators
``and'', ``or'', and ``not'', which may be used to evaluate calls to list
operators without the need for extra parentheses:
<p>
<XMP>
    open HANDLE, "filename"
        or die "Can't open: $!\n";

</XMP>
<p>See also discussion of list operators in 
<A HREF="perlop.html#perlop_terms_0"><EM>Terms and List Operators (Leftward)</EM></A>
.
<p>
<H2> 
<A NAME="perlop_logical_0">
Logical Not</A>
</H2>
Unary ``not'' returns the logical negation of the expression to its right.
It's the equivalent of ``!'' except for the very low precedence.
<p>
<H2> 
<A NAME="perlop_logical_1">
Logical And</A>
</H2>
Binary ``and'' returns the logical conjunction of the two surrounding
expressions.  It's equivalent to &amp;&amp; except for the very low
precedence.  This means that it short-circuits: i.e. the right
expression is evaluated only if the left expression is true.
<p>
<H2> 
<A NAME="perlop_logical_2">
Logical or and Exclusive Or</A>
</H2>
Binary ``or'' returns the logical disjunction of the two surrounding
expressions.  It's equivalent to || except for the very low
precedence.  This means that it short-circuits: i.e. the right
expression is evaluated only if the left expression is false.
<p>Binary ``xor'' returns the exclusive-OR of the two surrounding expressions.
It cannot short circuit, of course.
<p>
<H2> 
<A NAME="perlop_c_0">
C Operators Missing From Perl</A>
</H2>
Here is what C has that Perl doesn't:
<p>
<DL COMPACT>
<DT><STRONG>
<EM>unary &amp;</EM>
</STRONG>
<DD>
Address-of operator.  (But see the ``\'' operator for taking a reference.)
<p>
<DT><STRONG>

<A NAME="perlop_unary_1">
unary *</A>

</STRONG>
<DD>
Dereference-address operator. (Perl's prefix dereferencing 
operators are typed: $, @, %, and &amp;.)
<p>
<DT><STRONG>

<A NAME="perlop_type_0">
(TYPE)</A>

</STRONG>
<DD>
Type casting operator.  
<p>
</DL>

<H2> 
<A NAME="perlop_quote_0">
Quote and Quotelike Operators</A>
</H2>
While we usually think of quotes as literal values, in Perl they
function as operators, providing various kinds of interpolating and
pattern matching capabilities.  Perl provides customary quote characters
for these behaviors, but also provides a way for you to choose your
quote character for any of them.  In the following table, a <CODE>{}</CODE> represents
any pair of delimiters you choose.  Non-bracketing delimiters use
the same character fore and aft, but the 4 sorts of brackets 
(round, angle, square, curly) will all nest.
<p>
<XMP>
    Customary  Generic     Meaning    Interpolates
        ''       q{}       Literal         no
        ""      qq{}       Literal         yes
        ``      qx{}       Command         yes
                qw{}      Word list        no
        //       m{}    Pattern match      yes
                 s{}{}   Substitution      yes
                tr{}{}   Translation       no

</XMP>
<p>For constructs that do interpolation, variables beginning with ``<CODE>$</CODE>'' or ``<CODE>@</CODE>''
are interpolated, as are the following sequences:
<p>
<XMP>
    \t          tab             (HT, TAB)
    \n          newline         (LF, NL)
    \r          return          (CR)
    \f          form feed       (FF)
    \b          backspace       (BS)
    \a          alarm (bell)    (BEL)
    \e          escape          (ESC)
    \033        octal char
    \x1b        hex char
    \c[         control char
    \l          lowercase next char
    \u          uppercase next char
    \L          lowercase till \E
    \U          uppercase till \E
    \E          end case modification
    \Q          quote regexp metacharacters till \E

</XMP>
<p>Patterns are subject to an additional level of interpretation as a
regular expression.  This is done as a second pass, after variables are
interpolated, so that regular expressions may be incorporated into the
pattern from the variables.  If this is not what you want, use <CODE>\Q</CODE> to
interpolate a variable literally.
<p>Apart from the above, there are no multiple levels of interpolation.  In
particular, contrary to the expectations of shell programmers, backquotes
do <EM>NOT</EM> interpolate within double quotes, nor do single quotes impede
evaluation of variables when used within double quotes.
<p>
<H2> 
<A NAME="perlop_regexp_0">
Regexp Quotelike Operators</A>
</H2>
Here are the quotelike operators that apply to pattern
matching and related activities.
<p>
<DL COMPACT>
<DT><STRONG>

<A NAME="perlop_pattern_0">
?PATTERN?</A>

</STRONG>
<DD>
This is just like the <CODE>/pattern/</CODE> search, except that it matches only
once between calls to the <EM>reset()</EM> operator.  This is a useful
optimization when you only want to see the first occurrence of
something in each file of a set of files, for instance.  Only <CODE>??</CODE>
patterns local to the current package are reset.
<p>This usage is vaguely deprecated, and may be removed in some future
version of Perl.
<p>
<DT><STRONG>

<A NAME="perlop_m_pattern_gimosx_0">
m/PATTERN/gimosx</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlop_pattern_gimosx_0">
/PATTERN/gimosx</A>

</STRONG>
<DD>
Searches a string for a pattern match, and in a scalar context returns
true (1) or false ('').  If no string is specified via the <CODE>=~</CODE> or
<CODE>!~</CODE> operator, the <STRONG>$_</STRONG> string is searched.  (The string specified with
<CODE>=~</CODE> need not be an lvalue--it may be the result of an expression
evaluation, but remember the <CODE>=~</CODE> binds rather tightly.)  See also
the <EM>perlre</EM>  manpage
.
<p>Options are:
<p><UL><LI>    g	Match globally, i.e. find all occurrences.</LI>
<LI>    i	Do case-insensitive pattern matching.</LI>
<LI>    m	Treat string as multiple lines.</LI>
<LI>    o	Only compile pattern once.</LI>
<LI>    s	Treat string as single line.</LI>
<LI>    x	Use extended regular expressions.</LI>
</UL>
<p>If ``/'' is the delimiter then the initial <CODE>m</CODE> is optional.  With the <CODE>m</CODE>
you can use any pair of non-alphanumeric, non-whitespace characters as
delimiters.  This is particularly useful for matching Unix path names
that contain ``/'', to avoid LTS (leaning toothpick syndrome).
<p>PATTERN may contain variables, which will be interpolated (and the
pattern recompiled) every time the pattern search is evaluated.  (Note
that <CODE>$)</CODE> and <CODE>$|</CODE> might not be interpolated because they look like
end-of-string tests.)  If you want such a pattern to be compiled only
once, add a <CODE>/o</CODE> after the trailing delimiter.  This avoids expensive
run-time recompilations, and is useful when the value you are
interpolating won't change over the life of the script.  However, mentioning
<CODE>/o</CODE> constitutes a promise that you won't change the variables in the pattern.
If you change them, Perl won't even notice.
<p>If the PATTERN evaluates to a null string, the last
successfully executed regular expression is used instead.
<p>If used in a context that requires a list value, a pattern match returns a
list consisting of the subexpressions matched by the parentheses in the
pattern, i.e. (<CODE><STRONG>$1</STRONG></CODE>, <STRONG>$2</STRONG>, <STRONG>$3</STRONG>...).  (Note that here <STRONG>$1</STRONG> etc. are also set, and
that this differs from Perl 4's behavior.)  If the match fails, a null
array is returned.  If the match succeeds, but there were no parentheses,
a list value of (1) is returned.
<p>Examples:
<p>
<XMP>
    open(TTY, '/dev/tty');
    <TTY> =~ /^y/i && foo();    # do foo if desired
    if (/Version: *([0-9.]*)/) { $version = $1; }
    next if m#^/usr/spool/uucp#;
    # poor man's grep
    $arg = shift;
    while (<>) {
        print if /$arg/o;       # compile only once
    }
    if (($F1, $F2, $Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))

</XMP>
<p>This last example splits <STRONG>$foo</STRONG> into the first two words and the
remainder of the line, and assigns those three fields to <STRONG>$F1</STRONG>, <STRONG>$F2</STRONG> and
<STRONG>$Etc</STRONG>.  The conditional is true if any variables were assigned, i.e. if
the pattern matched.
<p>The <CODE>/g</CODE> modifier specifies global pattern matching--that is, matching
as many times as possible within the string.  How it behaves depends on
the context.  In a list context, it returns a list of all the
substrings matched by all the parentheses in the regular expression.
If there are no parentheses, it returns a list of all the matched
strings, as if there were parentheses around the whole pattern.
<p>In a scalar context, <CODE>m//g</CODE> iterates through the string, returning TRUE
each time it matches, and FALSE when it eventually runs out of
matches.  (In other words, it remembers where it left off last time and
restarts the search at that point.  You can actually find the current
match position of a string using the <EM>pos()</EM> function--see the <EM>perlfunc</EM>  manpage
.)
If you modify the string in any way, the match position is reset to the
beginning.  Examples:
<p>
<XMP>
    # list context
    ($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);
    # scalar context
    $/ = ""; $* = 1;  # $* deprecated in Perl 5
    while ($paragraph = <>) {
        while ($paragraph =~ /[a-z]['")]*[.!?]+['")]*\s/g) {
            $sentences++;
        }
    }
    print "$sentences\n";

</XMP>
<p>
<DT><STRONG>

<A NAME="perlop_q_string_0">
q/STRING/</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlop_string_0">
'STRING'</A>

</STRONG>
<DD>
A single-quoted, literal string.  Backslashes are ignored, unless
followed by the delimiter or another backslash, in which case the
delimiter or backslash is interpolated.
<p>
<XMP>
    $foo = q!I said, "You said, 'She said it.'"!;
    $bar = q('This is it.');

</XMP>
<p>
<DT><STRONG>

<A NAME="perlop_qq_string_0">
qq/STRING/</A>

</STRONG>
<DD>
<p>
<DT><STRONG>
<EM>``STRING''</EM>
</STRONG>
<DD>
A double-quoted, interpolated string.
<p>
<XMP>
    $_ .= qq
     (*** The previous line contains the naughty word "$1".\n)
                if /(tcl|rexx|python)/;      # :-)

</XMP>
<p>
<DT><STRONG>

<A NAME="perlop_qx_string_0">
qx/STRING/</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlop_string_2">
`STRING`</A>

</STRONG>
<DD>
A string which is interpolated and then executed as a system command.
The collected standard output of the command is returned.  In scalar
context, it comes back as a single (potentially multi-line) string.
In list context, returns a list of lines (however you've defined lines
with $/ or <STRONG>$INPUT_RECORD_SEPARATOR</STRONG>).
<p>
<XMP>
    $today = qx{ date };

</XMP>
<p>See 
<A HREF="perlop.html#perlop_i_o_0"><EM>I/O Operators</EM></A>
 for more discussion.
<p>
<DT><STRONG>

<A NAME="perlop_qw_string_0">
qw/STRING/</A>

</STRONG>
<DD>
Returns a list of the words extracted out of STRING, using embedded
whitespace as the word delimiters.  It is exactly equivalent to
<p>
<XMP>
    split(' ', q/STRING/);

</XMP>
<p>Some frequently seen examples:
<p>
<XMP>
    use POSIX qw( setlocale localeconv )
    @EXPORT = qw( foo bar baz );

</XMP>
<p>
<DT><STRONG>

<A NAME="perlop_s_pattern_replacement_egimosx_0">
s/PATTERN/REPLACEMENT/egimosx</A>

</STRONG>
<DD>
Searches a string for a pattern, and if found, replaces that pattern
with the replacement text and returns the number of substitutions
made.  Otherwise it returns false (specifically, the empty string).
<p>If no string is specified via the <CODE>=~</CODE> or <CODE>!~</CODE> operator, the <CODE><STRONG>$_</STRONG></CODE>
variable is searched and modified.  (The string specified with <CODE>=~</CODE> must
be a scalar variable, an array element, a hash element, or an assignment
to one of those, i.e. an lvalue.)
<p>If the delimiter chosen is single quote, no variable interpolation is
done on either the PATTERN or the REPLACEMENT.  Otherwise, if the
PATTERN contains a <STRONG>$ </STRONG>that looks like a variable rather than an
end-of-string test, the variable will be interpolated into the pattern
at run-time.  If you only want the pattern compiled once the first time
the variable is interpolated, use the <CODE>/o</CODE> option.  If the pattern
evaluates to a null string, the last successfully executed regular
expression is used instead.  See the <EM>perlre</EM>  manpage
 for further explanation on these.
<p>Options are:
<p><UL><LI>    e	Evaluate the right side as an expression.</LI>
<LI>    g	Replace globally, i.e. all occurrences.</LI>
<LI>    i	Do case-insensitive pattern matching.</LI>
<LI>    m	Treat string as multiple lines.</LI>
<LI>    o	Only compile pattern once.</LI>
<LI>    s	Treat string as single line.</LI>
<LI>    x	Use extended regular expressions.</LI>
</UL>
<p>Any non-alphanumeric, non-whitespace delimiter may replace the
slashes.  If single quotes are used, no interpretation is done on the
replacement string (the <CODE>/e</CODE> modifier overrides this, however).  Unlike
Perl 4, Perl 5 treats backticks as normal delimiters; the replacement
text is not evaluated as a command.  If the
PATTERN is delimited by bracketing quotes, the REPLACEMENT has its own
pair of quotes, which may or may not be bracketing quotes, e.g.
<CODE>s(foo)(bar)</CODE> or <CODE>s&lt;foo&gt;/bar/</CODE>.  A <CODE>/e</CODE> will cause the
replacement portion to be interpreter as a full-fledged Perl expression
and <EM>eval()</EM>ed right then and there.  It is, however, syntax checked at
compile-time.
<p>Examples:
<p>
<XMP>
    s/\bgreen\b/mauve/g;                # don't change wintergreen
    $path =~ s|/usr/bin|/usr/local/bin|;
    s/Login: $foo/Login: $bar/; # run-time pattern
    ($foo = $bar) =~ s/this/that/;
    $count = ($paragraph =~ s/Mister\b/Mr./g);
    $_ = 'abc123xyz';
    s/\d+/$&*2/e;               # yields 'abc246xyz'
    s/\d+/sprintf("%5d",$&)/e;  # yields 'abc  246xyz'
    s/\w/$& x 2/eg;             # yields 'aabbcc  224466xxyyzz'
    s/%(.)/$percent{$1}/g;      # change percent escapes; no /e
    s/%(.)/$percent{$1} || $&/ge;       # expr now, so /e
    s/^=(\w+)/&pod($1)/ge;      # use function call
    # /e's can even nest;  this will expand
    # simple embedded variables in $_
    s/(\$\w+)/$1/eeg;
    # Delete C comments.
    $program =~ s {
        /\*     # Match the opening delimiter.
        .*?     # Match a minimal number of characters.
        \*/     # Match the closing delimiter.
    } []gsx;
    s/^\s*(.*?)\s*$/$1/;        # trim white space
    s/([^ ]*) *([^ ]*)/$2 $1/;  # reverse 1st two fields

</XMP>
<p>Note the use of <STRONG>$ </STRONG>instead of \ in the last example.  Unlike 
<STRONG>sed</STRONG>, we only use the \&lt;<EM>digit</EM>&gt; form in the left hand side.
Anywhere else it's $&lt;<EM>digit</EM>&gt;.
<p>Occasionally, you can't just use a <CODE>/g</CODE> to get all the changes
to occur.  Here are two common cases:
<p>
<XMP>
    # put commas in the right places in an integer
    1 while s/(.*\d)(\d\d\d)/$1,$2/g;      # perl4
    1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/g;  # perl5
    # expand tabs to 8-column spacing
    1 while s/\t+/' ' x (length($&)*8 - length($`)%8)/e;

</XMP>
<p>
<DT><STRONG>

<A NAME="perlop_tr_searchlist_replacementlist_cds_0">
tr/SEARCHLIST/REPLACEMENTLIST/cds</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlop_y_searchlist_replacementlist_cds_0">
y/SEARCHLIST/REPLACEMENTLIST/cds</A>

</STRONG>
<DD>
Translates all occurrences of the characters found in the search list
with the corresponding character in the replacement list.  It returns
the number of characters replaced or deleted.  If no string is
specified via the =~ or !~ operator, the <STRONG>$_</STRONG> string is translated.  (The
string specified with =~ must be a scalar variable, an array element,
or an assignment to one of those, i.e. an lvalue.)  For <STRONG>sed</STRONG> devotees,
<CODE>y</CODE> is provided as a synonym for <CODE>tr</CODE>.  If the SEARCHLIST is
delimited by bracketing quotes, the REPLACEMENTLIST has its own pair of
quotes, which may or may not be bracketing quotes, e.g. <CODE>tr[A-Z][a-z]</CODE>
or <CODE>tr(+-*/)/ABCD/</CODE>.
<p>Options:
<p><UL><LI>    c	Complement the SEARCHLIST.</LI>
<LI>    d	Delete found but unreplaced characters.</LI>
<LI>    s	Squash duplicate replaced characters.</LI>
</UL>
<p>If the <CODE>/c</CODE> modifier is specified, the SEARCHLIST character set is
complemented.  If the <CODE>/d</CODE> modifier is specified, any characters specified
by SEARCHLIST not found in REPLACEMENTLIST are deleted.  (Note
that this is slightly more flexible than the behavior of some <STRONG>tr</STRONG>
programs, which delete anything they find in the SEARCHLIST, period.)
If the <CODE>/s</CODE> modifier is specified, sequences of characters that were
translated to the same character are squashed down to a single instance of the
character.
<p>If the <CODE>/d</CODE> modifier is used, the REPLACEMENTLIST is always interpreted
exactly as specified.  Otherwise, if the REPLACEMENTLIST is shorter
than the SEARCHLIST, the final character is replicated till it is long
enough.  If the REPLACEMENTLIST is null, the SEARCHLIST is replicated.
This latter is useful for counting characters in a class or for
squashing character sequences in a class.
<p>Examples:
<p>
<XMP>
    $ARGV[1] =~ tr/A-Z/a-z/;    # canonicalize to lower case
    $cnt = tr/*/*/;             # count the stars in $_
    $cnt = $sky =~ tr/*/*/;     # count the stars in $sky
    $cnt = tr/0-9//;            # count the digits in $_
    tr/a-zA-Z//s;               # bookkeeper -> bokeper
    ($HOST = $host) =~ tr/a-z/A-Z/;
    tr/a-zA-Z/ /cs;             # change non-alphas to single space
    tr [\200-\377]
       [\000-\177];             # delete 8th bit

</XMP>
<p>If multiple translations are given for a character, only the first one is used:
<p>
<XMP>
    tr/AAA/XYZ/

</XMP>
<p>will translate any A to X.
<p>Note that because the translation table is built at compile time, neither
the SEARCHLIST nor the REPLACEMENTLIST are subjected to double quote
interpolation.  That means that if you want to use variables, you must use
an <EM>eval()</EM>:
<p>
<XMP>
    eval "tr/$oldlist/$newlist/";
    die $@ if $@;
    eval "tr/$oldlist/$newlist/, 1" or die $@;

</XMP>
<p>
</DL>

<H2> 
<A NAME="perlop_i_o_0">
I/O Operators</A>
</H2>
There are several I/O operators you should know about.  
A string is enclosed by backticks (grave accents) first undergoes
variable substitution just like a double quoted string.  It is then
interpreted as a command, and the output of that command is the value
of the pseudo-literal, like in a shell.  In a scalar context, a single
string consisting of all the output is returned.  In a list context,
a list of values is returned, one for each line of output.  (You can
set <CODE>$/</CODE> to use a different line terminator.)  The command is executed
each time the pseudo-literal is evaluated.  The status value of the
command is returned in <CODE>$?</CODE> (see the <EM>perlvar</EM>  manpage
 for the interpretation
of <CODE>$?</CODE>).  Unlike in <STRONG>csh</STRONG>, no translation is done on the return
data--newlines remain newlines.  Unlike in any of the shells, single
quotes do not hide variable names in the command from interpretation.
To pass a <STRONG>$ </STRONG>through to the shell you need to hide it with a backslash.
The generalized form of backticks is 
<A HREF="perlop.html#perlop_qx_string_0">qx//</A>
.  (Because backticks
always undergo shell expansion as well, see the <EM>perlsec</EM>  manpage
 for 
security concerns.)
<p>Evaluating a filehandle in angle brackets yields the next line from
that file (newline included, so it's never false until end of file, at
which time an undefined value is returned).  Ordinarily you must assign
that value to a variable, but there is one situation where an automatic
assignment happens.  <EM>If and ONLY if</EM> the input symbol is the only
thing inside the conditional of a <CODE>while</CODE> loop, the value is
automatically assigned to the variable <CODE><STRONG>$_</STRONG></CODE>.  The assigned value is
then tested to see if it is defined.  (This may seem like an odd thing
to you, but you'll use the construct in almost every Perl script you
write.)  Anyway, the following lines are equivalent to each other:
<p>
<XMP>
    while (defined($_ = <STDIN>)) { print; }
    while (<STDIN>) { print; }
    for (;<STDIN>;) { print; }
    print while defined($_ = <STDIN>);
    print while <STDIN>;

</XMP>
<p>The filehandles STDIN, STDOUT and STDERR are predefined.  (The
filehandles <CODE>stdin</CODE>, <CODE>stdout</CODE> and <CODE>stderr</CODE> will also work except in
packages, where they would be interpreted as local identifiers rather
than global.)  Additional filehandles may be created with the <EM>open()</EM>
function.  See <EM>open</EM> for details on this.
<p>If a &lt;FILEHANDLE&gt; is used in a context that is looking for a list, a
list consisting of all the input lines is returned, one line per list
element.  It's easy to make a <EM>LARGE</EM> data space this way, so use with
care.
<p>The null filehandle &lt;&gt; is special and can be used to emulate the
behavior of <STRONG>sed</STRONG> and <STRONG>awk</STRONG>.  Input from &lt;&gt; comes either from
standard input, or from each file listed on the command line.  Here's
how it works: the first time &lt;&gt; is evaluated, the <STRONG>@ARGV</STRONG> array is
checked, and if it is null, <CODE><STRONG>$ARGV</STRONG>[0]</CODE> is set to ``-'', which when opened
gives you standard input.  The <STRONG>@ARGV</STRONG> array is then processed as a list
of filenames.  The loop
<p>
<XMP>
    while (<>) {
        ...                     # code for each line
    }

</XMP>
<p>is equivalent to the following Perl-like pseudo code:
<p>
<XMP>
    unshift(@ARGV, '-') if $#ARGV < $[;
    while ($ARGV = shift) {
        open(ARGV, $ARGV);
        while (<ARGV>) {
            ...         # code for each line
        }
    }

</XMP>
<p>except that it isn't so cumbersome to say, and will actually work.  It
really does shift array <STRONG>@ARGV</STRONG> and put the current filename into variable
<STRONG>$ARGV</STRONG>.  It also uses filehandle <EM>ARGV</EM> internally--&lt;&gt; is just a synonym
for &lt;ARGV&gt;, which is magical.  (The pseudo code above doesn't work
because it treats &lt;ARGV&gt; as non-magical.)
<p>You can modify <STRONG>@ARGV</STRONG> before the first &lt;&gt; as long as the array ends up
containing the list of filenames you really want.  Line numbers (<CODE>$.</CODE>)
continue as if the input were one big happy file.  (But see example
under <EM>eof()</EM> for how to reset line numbers on each file.)
<p>If you want to set <STRONG>@ARGV</STRONG> to your own list of files, go right ahead.  If
you want to pass switches into your script, you can use one of the 
Getopts modules or put a loop on the front like this:
<p>
<XMP>
    while ($_ = $ARGV[0], /^-/) {
        shift;
        last if /^--$/;
        if (/^-D(.*)/) { $debug = $1 }
        if (/^-v/)     { $verbose++  }
        ...             # other switches
    }
    while (<>) {
        ...             # code for each line
    }

</XMP>
<p>The &lt;&gt; symbol will return FALSE only once.  If you call it again after
this it will assume you are processing another <STRONG>@ARGV</STRONG> list, and if you
haven't set <STRONG>@ARGV</STRONG>, will input from STDIN.
<p>If the string inside the angle brackets is a reference to a scalar
variable (e.g. &lt;<STRONG>$foo</STRONG>&gt;), then that variable contains the name of the
filehandle to input from, or a reference to the same.  For example:
<p>
<XMP>
    $fh = \*STDIN;
    $line = <$fh>;

</XMP>
<p>If the string inside angle brackets is not a filehandle or a scalar
variable containing a filehandle name or reference, then it is interpreted
as a filename pattern to be globbed, and either a list of filenames or the
next filename in the list is returned, depending on context.  One level of
<STRONG>$ </STRONG>interpretation is done first, but you can't say <CODE>&lt;<STRONG>$foo</STRONG>&gt;</CODE>
because that's an indirect filehandle as explained in the previous
paragraph.  (In older versions of Perl, programmers would insert curly
brackets to force interpretation as a filename glob: <CODE>&lt;<STRONG>${</STRONG>foo}&gt;</CODE>.
These days, it's considered cleaner to call the internal function directly
as <CODE>glob(<STRONG>$foo</STRONG>)</CODE>, which is probably the right way to have done it in the
first place.)  Example:
<p>
<XMP>
    while (<*.c>) {
        chmod 0644, $_;
    }

</XMP>
<p>is equivalent to
<p>
<XMP>
    open(FOO, "echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|");
    while (<FOO>) {
        chop;
        chmod 0644, $_;
    }

</XMP>
<p>In fact, it's currently implemented that way.  (Which means it will not
work on filenames with spaces in them unless you have csh(1) on your
machine.)  Of course, the shortest way to do the above is:
<p>
<XMP>
    chmod 0644, <*.c>;

</XMP>
<p>Because globbing invokes a shell, it's often faster to call <EM>readdir()</EM> yourself
and just do your own <EM>grep()</EM> on the filenames.  Furthermore, due to its current
implementation of using a shell, the <EM>glob()</EM> routine may get "Arg list too 
long" errors (unless you've installed tcsh(1L) as <EM>/bin/csh</EM>).
<p>A glob only evaluates its (embedded) argument when it is starting a new
list.  All values must be read before it will start over.  In a list
context this isn't important, because you automatically get them all
anyway.  In a scalar context, however, the operator returns the next value
each time it is called, or a FALSE value if you've just run out.  Again,
FALSE is returned only once.  So if you're expecting a single value from
a glob, it is much better to say
<p>
<XMP>
    ($file) = <blurch*>;

</XMP>
<p>than
<p>
<XMP>
    $file = <blurch*>;

</XMP>
<p>because the latter will alternate between returning a filename and
returning FALSE.  
<p>It you're trying to do variable interpolation, it's definitely better
to use the <EM>glob()</EM> function, because the older notation can cause people
to become confused with the indirect filehandle notation.
<p>
<XMP>
    @files = glob("$dir/*.[ch]");
    @files = glob($files[$i]);

</XMP>
<p>
<H2> 
<A NAME="perlop_constant_0">
Constant Folding</A>
</H2>
Like C, Perl does a certain amount of expression evaluation at
compile time, whenever it determines that all of the arguments to an
operator are static and have no side effects.  In particular, string
concatenation happens at compile time between literals that don't do
variable substitution.  Backslash interpretation also happens at
compile time.  You can say
<p>
<XMP>
    'Now is the time for all' . "\n" .
        'good men to come to.'

</XMP>
<p>and this all reduces to one string internally.  Likewise, if 
you say
<p>
<XMP>
    foreach $file (@filenames) {
        if (-s $file > 5 + 100 * 2**16) { ... }
    } 

</XMP>
<p>the compiler will pre-compute the number that
expression represents so that the interpreter
won't have to.
<p>
<H2> 
<A NAME="perlop_integer_0">
Integer arithmetic</A>
</H2>
By default Perl assumes that it must do most of its arithmetic in
floating point.  But by saying
<p>
<XMP>
    use integer;

</XMP>
<p>you may tell the compiler that it's okay to use integer operations
from here to the end of the enclosing BLOCK.  An inner BLOCK may
countermand this by saying 
<p>
<XMP>
    no integer;

</XMP>
<p>which lasts until the end of that BLOCK.
<p>
</BODY>
</HTML>
